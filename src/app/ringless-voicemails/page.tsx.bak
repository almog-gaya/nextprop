'use client';

import { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { PhoneNumber, useAuth } from '@/contexts/AuthContext';
import DashboardLayout from '@/components/DashboardLayout';
import DashboardHeader from '@/components/dashboard/DashboardHeader';
import axios from 'axios';
import Link from 'next/link';
import toast from 'react-hot-toast';
import StatsCard from '@/components/StatsCard';
import BulkUploadForm from '@/components/BulkUploadForm';
import { collection, query, onSnapshot, where, setDoc, doc, deleteDoc, orderBy } from 'firebase/firestore';
import { db } from '@/lib/firebaseConfig';
import ContactSelector from '@/components/ringless-voicemail/ContactSelector';
import CampaignForm from '@/components/ringless-voicemail/CampaignForm';
import CampaignList from '@/components/ringless-voicemail/CampaignList';
import {
  PlayIcon,
  PauseIcon,
  PhoneIcon,
  PhoneOffIcon,
  PhoneIncomingIcon,
  CheckCircleIcon,
  XCircleIcon,
  ClockIcon,
  TrashIcon
} from 'lucide-react';
import PipelineSelector from '@/components/dashboard/PipelineSelector';
import StageSelector from '@/components/dashboard/StageSelector';
import ViewToggle from '@/components/dashboard/ViewToggel';
import EnhancedBulkUploadForm from '@/components/EnhancedBulkUploadForm';

export default function RinglessVoicemailPage() {
  const { user, loadUser } = useAuth();
  const [campaigns, setCampaigns] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [pipelines, setPipelines] = useState<any[]>([]);
  const [selectedPipeline, setSelectedPipeline] = useState<string | null>(null);
  const [selectedStage, setSelectedStage] = useState<string | null>('all');
  const [pipelineStages, setPipelineStages] = useState<any[]>([]);
  const [totalLeadsByPipeline, setTotalLeadsByPipeline] = useState<Record<string, number>>({});
  const [totalLeadsByStage, setTotalLeadsByStage] = useState<Record<string, number>>({});
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');
  const [apiConfigured, setApiConfigured] = useState(true);
  const [notification, setNotification] = useState({ message: '', type: '' });
  const [notificationActive, setNotificationActive] = useState(false);
  const [settings, setSettings] = useState({
    delayMinutes: 5,
    dailyLimit: 50,
    startTime: "10:00 AM",
    endTime: "5:00 PM",
    timezone: "America/New_York",
    maxPerHour: 100,
    daysOfWeek: ["Mon", "Tue", "Wed", "Thu", "Fri"]
  });

  // Add a state to track the filtered contact count for the selected stage
  const [stageContactCount, setStageContactCount] = useState<number | null>(null);

  // Add this with your other state declarations
  const [loadingProgress, setLoadingProgress] = useState<{current: number, total: number} | null>(null);

  // Add a new state for tracking if filters have been applied
  const [filtersApplied, setFiltersApplied] = useState(false);

  useEffect(() => {
    if (!user && !loading) {
      loadUser();
    }
  }, [user, loading, loadUser]);

  useEffect(() => {
    if (user && !loading) {
      fetchPhoneNumbers();
    }
  }, [user, loading]);

  const dayMapping: { [key: string]: string } = {
    Mon: "Monday",
    Tue: "Tuesday",
    Wed: "Wednesday",
    Thu: "Thursday",
    Fri: "Friday",
    Sat: "Saturday",
    Sun: "Sunday",
  };

  const convertTo24Hour = (time: string) => {
    if (/^\d{2}:\d{2}$/.test(time)) {
      // Already in 24-hour format, return as-is
      return time;
    }

    const [hourStr, minuteStr, period] = time.split(/:| /);
    let hour = parseInt(hourStr, 10);

    if (period?.toUpperCase() === "PM" && hour !== 12) {
      hour += 12;
    } else if (period?.toUpperCase() === "AM" && hour === 12) {
      hour = 0;
    }

    return `${String(hour).padStart(2, "0")}:${minuteStr}`;
  };

  // Contact management state
  const [contacts, setContacts] = useState<any[]>([]);
  const [selectedContacts, setSelectedContacts] = useState<any[]>([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [totalContacts, setTotalContacts] = useState(0);
  const [currentPage, setCurrentPage] = useState(1);
  const [isFetching, setIsFetching] = useState(false);
  const [isSearching, setIsSearching] = useState(false);
  const loaderRef = useRef<HTMLLIElement>(null);

  // Campaign creation state
  const [campaignName, setCampaignName] = useState('');
  const [script, setScript] = useState('');
  const [voiceClones, setVoiceClones] = useState<any[]>([]);
  const [selectedVoiceClone, setSelectedVoiceClone] = useState<string>('');
  const [phoneNumbers, setPhoneNumbers] = useState<any[]>([]);
  const [selectedPhoneNumber, setSelectedPhoneNumber] = useState<any>(null);

  // Modal state
  const [isBulkUploadModalOpen, setIsBulkUploadModalOpen] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Constants
  const CONTACTS_PER_PAGE = 10;

  // Stats derived from campaigns
  const stats = useMemo(() => {
    if (!campaigns || campaigns.length === 0) {
      return {
        totalContacts: 0,
        delivered: 0,
        pending: 0,
        failed: 0,
        activeCampaigns: 0
      };
    }

    return {
      totalContacts: campaigns.reduce((acc, campaign) => acc + (campaign.total_contacts || 0), 0),
      delivered: campaigns.reduce((acc, campaign) => acc + (campaign.processed_contacts || 0), 0),
      pending: campaigns.reduce((acc, campaign) => {
        const total = campaign.total_contacts || 0;
        const processed = campaign.processed_contacts || 0;
        return acc + (total - processed > 0 ? total - processed : 0);
      }, 0),
      failed: campaigns.reduce((acc, campaign) => acc + (campaign.failed_contacts || 0), 0),
      activeCampaigns: campaigns.filter(c =>
        (c.status === 'active' || c.status === 'running') && !c.paused
      ).length
    };
  }, [campaigns]);

  useEffect(() => {
    let unsubscribe: any;

    const fetchData = async () => {
      unsubscribe = await fetchCampaigns();
      fetchPhoneNumbers();
      fetchVoiceClones();
    };

    fetchData();

    return () => {
      if (unsubscribe) unsubscribe();
    };
  }, []);

  const searchTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const handleSearchChange = useCallback((value: string) => {
    if (searchTimeoutRef.current) {
      clearTimeout(searchTimeoutRef.current);
    }
    
    searchTimeoutRef.current = setTimeout(() => {
      setSearchQuery(value);
    }, 300);
  }, []);

  useEffect(() => {
    return () => {
      if (searchTimeoutRef.current) {
        clearTimeout(searchTimeoutRef.current);
      }
    };
  }, []);

  async function fetchCampaigns() {
    setLoading(true);
    let unsubscribe: (() => void) | undefined;

    try {
      const locationId = user?.locationId ?? await getLocationId();
      const campaignsCollection = collection(db, 'campaigns');
      const campaignsQuery = query(campaignsCollection, 
        where("customer_id", "==", locationId),
        where("channels.voicedrop.enabled", "==", true),
        orderBy("created_at", "desc")
    );

      unsubscribe = onSnapshot(campaignsQuery, (querySnapshot) => {
        const campaignsData: any[] = [];
        querySnapshot.forEach((doc) => {
          campaignsData.push({ id: doc.id, ...doc.data() });
        });

        console.log('Fetched campaigns:', campaignsData);
        setCampaigns(campaignsData);
        setError(null);
      });

      return unsubscribe;
    } catch (error) {
      console.error('Error fetching campaigns:', error);
      setError('Failed to load campaign data');
      toast.error('Failed to load campaign data');
      throw error;
    } finally {
      setLoading(false);
    }
  }

  async function getLocationId(): Promise<string> {
    try {
      const response = await fetch('/api/auth/ghl/location-id');
      if (!response.ok) {
        throw new Error(`Failed to fetch location ID: ${response.status}`);
      }
      const data = await response.json();
      if (!data.locationId) {
        throw new Error('Location ID not found in response');
      }
      return data.locationId;
    } catch (error) {
      console.error('Error fetching location ID:', error);
      throw error;
    }
  }

  async function fetchPhoneNumbers() {
    try {
      const userNumbers = user?.phoneNumbers || [];
      const numbersArray = userNumbers.map((number: PhoneNumber) => number.phoneNumber);
      setPhoneNumbers(numbersArray);
    } catch (error) {
      console.error('Error fetching phone numbers:', error);
      toast.error('Failed to load phone numbers');
      setPhoneNumbers([]);
      setSelectedPhoneNumber(null);
    }
  }

  async function fetchVoiceClones() {
    try {
      const response = await axios.get('/api/voicemail/voice-clones');
      setVoiceClones(response.data);
    } catch (error) {
      console.error('Error fetching voice clones:', error);
      toast.error('Failed to load voice clones');
      const defaultVoiceClones = [
        { id: "61EQ2khjAy41AXCqUSSS", name: "Cecilia" },
        { id: "Es45QkMNPudcZKVRZWPs", name: "Rey" },
        { id: "dodUUtwsqo09HrH2RO8w", name: "Default Voice" }
      ];
      setVoiceClones(defaultVoiceClones);
    }
  }

  async function handleCampaignAction(id: string, action: string) {
    try {
      const actionMessages: Record<string, string> = {
        start: 'Campaign started',
        pause: 'Campaign paused',
        resume: 'Campaign resumed',
        stop: 'Campaign stopped',
      };
      console.log(`Handling ${action} action for campaign with ID:`, id);
      // return;

      const result = await fetch(`/api/voicemail/action?campaignId=${id}&action=${action}`, {

      })

      toast.success(actionMessages[action as keyof typeof actionMessages] || 'Campaign updated');

    } catch (error) {
      console.error(`Error ${action} campaign:`, error);
      toast.error(`Failed to ${action} campaign`);
    }
  }

  async function handleDeleteCampaign(id: string) {
    if (!confirm('Are you sure you want to delete this campaign? This action cannot be undone.')) {
      return;
    }

    try {
      const campaignDoc = doc(db, "campaigns", id);
      await deleteDoc(campaignDoc);
      toast.success('Campaign deleted');
    } catch (error) {
      console.error('Error deleting campaign:', error);
      toast.error('Failed to delete campaign');
    }
  }

  async function handleUpdateSettings(newSettings: any) {
    console.log('Updating settings:', newSettings);
    setSettings(newSettings);
    toast.success('Settings saved');
  }

  async function createCampaign() {
    if (!selectedPipeline) {
      toast.error('Please select a pipeline first');
      return;
    }

    if (selectedContacts.length === 0) {
      toast.error('Please select at least one contact');
      return;
    }

    if (!selectedPhoneNumber) {
      toast.error('Please select a phone number');
      return;
    }

    if (!script) {
      toast.error('Please provide a campaign script');
      return;
    }

    if (!campaignName) {
      toast.error('Please provide a campaign name');
      return;
    }

    try {
      setLoading(true);

      const formattedContacts = selectedContacts.map(contact => {
        const contactData: Record<string, any> = {
          phone_number: contact.phone,
          first_name: contact.firstName || contact.contactName || 'Unknown',
          street_name: contact.address1 || contact.street || 'your area',
          city: contact.city,
          state: contact.state,
          country: contact.country,
          postalCode: contact.postalCode,
        };
        
        // Remove null or undefined values
        Object.keys(contactData).forEach(key => {
          if (contactData[key] === null || contactData[key] === undefined) {
            delete contactData[key];
          }
        });
        
        return contactData;
      });

      const campaignPayload = {
        'customer_id': user?.locationId,
        'name': campaignName,
        'days': settings.daysOfWeek.map(day => dayMapping[day] || day),
        'timezone': settings.timezone === "EST (New York)" ? "America/New_York" : settings.timezone,
        'time_window': {
          start: convertTo24Hour(settings.startTime),
          end: convertTo24Hour(settings.endTime)
        },
        'channels': {
          'voicedrop': {
            'enabled': true,
            'message': script,
            'voice_clone_id': selectedVoiceClone || "dodUUtwsqo09HrH2RO8w",
            'from_number': selectedPhoneNumber.number || selectedPhoneNumber,
            'max_calls_per_hour': settings.maxPerHour,
          }
        },
        'contacts': formattedContacts,
      }
      const response = await fetch("/api/voicemail", {
        method: "POST",
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(campaignPayload)
      });
      const data = await response.json();
      if(data.campaign_id) {
        toast.success(`Campaign created successfully with total ${data.total_contacts_added} contacts`);
      } else {
        const errorMessages = data.detail.map((err: any) => {
          // Extract the field name from the 'loc' array (last element is the field name)
          const fieldName = err.loc[err.loc.length - 1];
          return `'${fieldName}' must be a valid string`;
        }).join(', ');
        toast.error(errorMessages,
          {
            duration: 10000,
            position: "top-right",  
          }
        ); 
      }
     
      setSelectedContacts([]);
      setCampaignName('');
      setScript('');
      setSelectedPhoneNumber(phoneNumbers[0] || null);
      setSelectedVoiceClone('');
      fetchCampaigns();

      return data;
    } catch (error: any) {
      console.error('Error creating campaign:', error);
      toast.error(error?.message || error?.response?.data?.message || 'Failed to create campaign');
      throw error;
    } finally {
      setLoading(false);
    }
  }

  const toggleContact = (contact: any) => {
    setSelectedContacts((prev) =>
      prev.some((c) => c.id === contact.id) ? prev.filter((c) => c.id !== contact.id) : [...prev, contact]
    );
  };

  const generateDefaultScript = () => {
    setScript(
      `Hi {{first_name}}, this is ${user?.firstName || user?.name || 'Adforce'} from NextProp. I noticed you might be interested in properties in your area. I've got some great listings on {{street_name}} that match your criteria. Call me back when you have a chance and we can discuss your needs. Thanks!`
    );
  };

  const handleBulkUpload = async (contacts: any) => {
    setIsSubmitting(true);
    try {
      let selectedPipelineId = null;
      let selectedStageId = null;
      const uploadResults = await Promise.all(
        contacts.map(async (contact: any) => {
          try {
            selectedPipelineId = contact.pipelineId;
            selectedStageId = contact.stageId;
            const response = await axios.post('/api/contacts', {
              firstName: contact.firstName,
              lastName: contact.lastName,
              phone: contact.phone,
              address1: contact.street,
              city: contact.city,
              state: contact.state,
              email: contact.email,
              source: 'bulk_upload',
              postalCode: contact.zipCode,
            });
            return { success: true, contact: response.data.contact };
          } catch (error) {
            console.warn(`Failed to upload contact "${contact.firstName || contact.phone}":`, error);
            return { success: false, contact: null };
          }
        })
      );

      const successfulUploads = uploadResults.filter((result) => result.success);
      const processedContacts = successfulUploads.map((result) => result.contact);
      setContacts((prev) => [...processedContacts, ...prev]);
      setTotalContacts((prev) => prev + successfulUploads.length);
      setSelectedContacts(processedContacts);

      toast.success(`${successfulUploads.length} contacts added successfully`);
      setIsBulkUploadModalOpen(false);
      if (selectedPipelineId && selectedStageId) {
        addContactsToPipeline(selectedPipelineId, selectedStageId, processedContacts);
      }
    } catch (error: any) {
      toast.error(error.response?.data?.error || 'Failed to add contacts');
    } finally {
      setIsSubmitting(false);
    }
  };

  const addContactsToPipeline = async (pipelineId: string, stageId: string, contacts: any[]) => {
    try {
      const results = await Promise.allSettled(
        contacts.map(async (contact: any) => {
          try {
            const response = await fetch('/api/opportunities', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                pipelineId: pipelineId,
                pipelineStageId: stageId,
                contactId: contact.id,
                status: "open",
                name: `${contact.firstName} ${contact.lastName} - ${contact.address1 ?? `${contact.street}, ${contact.city}, ${contact.state} ${contact.zipCode}`}`.trim()
              }),
            });

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            return { contact, success: true };
          } catch (error) {
            console.error(`Failed to add contact ${contact.id} to pipeline:`, error);
            return { contact, success: false, error };
          }
        })
      );

      const successful = results.filter(result => result.status === 'fulfilled' && result.value.success);
      const failed = results.filter(result => result.status === 'rejected' || !result.value.success);

      if (failed.length > 0) {
        toast.error(`${failed.length} contacts failed to add to pipeline`);
      }

      if (successful.length > 0) {
        toast.success(`${successful.length} contacts added to pipeline successfully`);
      }

      return { successful, failed };
    } catch (error) {
      console.error('Unexpected error in addContactsToPipeline:', error);
      toast.error('An unexpected error occurred while adding contacts to pipeline');
      return { successful: [], failed: contacts.map(contact => ({ contact, success: false, error })) };
    }
  };

  // Update the handlePipelineChange function to load stage counts immediately
  const handlePipelineChange = (pipelineId: string) => {
    console.log('Pipeline changed to:', pipelineId);
    setSelectedPipeline(pipelineId);
    // Reset filtersApplied when changing pipeline
    setFiltersApplied(false);
    
    // Update available stages for the selected pipeline
    const selectedPipelineData = pipelines.find((p: any) => p.id === pipelineId);
    if (selectedPipelineData) {
      console.log('Selected pipeline:', selectedPipelineData.name, '(ID:', pipelineId, ')');
      console.log('Pipeline data:', selectedPipelineData);
      
      // Set the stages
      setPipelineStages(selectedPipelineData.stages || []);
      
      // Immediately fetch counts for all stages in this pipeline
      fetchStageCountsForPipeline(pipelineId, selectedPipelineData.stages || []);
    } else {
      console.error('Could not find pipeline with ID:', pipelineId);
      setPipelineStages([]);
    }
  };

  // Add a new function to fetch counts for all stages in a pipeline
  const fetchStageCountsForPipeline = async (pipelineId: string, stages: any[]) => {
    try {
      // Show loading state
      toast.loading('Loading stage counts...');
      
      // Fetch counts for each stage in parallel
      const stageCounts = await Promise.all(
        stages.map(async (stage) => {
          try {
            const count = await fetchStageContacts(pipelineId, stage.id);
            return { stageId: stage.id, count };
          } catch (error) {
            console.error(`Error fetching count for stage ${stage.id}:`, error);
            return { stageId: stage.id, count: 0 };
          }
        })
      );
      
      // Update stage counts
      const newCounts = { ...totalLeadsByStage };
      stageCounts.forEach(({ stageId, count }) => {
        newCounts[stageId] = count;
      });
      setTotalLeadsByStage(newCounts);
      
      // Calculate pipeline total
      const pipelineTotal = stageCounts.reduce((sum, { count }) => sum + count, 0);
      setTotalLeadsByPipeline({ ...totalLeadsByPipeline, [pipelineId]: pipelineTotal });
      
      // Dismiss loading toast
      toast.dismiss();
      toast.success('Pipeline data loaded');
    } catch (error) {
      console.error('Error fetching stage counts:', error);
      toast.error('Error loading stage counts');
    }
  };

  // Update handleStageChange to use the data we already have
  const handleStageChange = (stageId: string) => {
    setSelectedStage(stageId);
    // Do not reset filters applied right away
    
    // Set stage count from our already fetched data
    if (stageId && stageId !== 'all' && totalLeadsByStage[stageId] !== undefined) {
      setStageContactCount(totalLeadsByStage[stageId]);
    } else {
      setStageContactCount(null);
    }
  };

  // Add better error handling to fetchStageContacts
  const fetchStageContacts = async (pipelineId: string, stageId: string) => {
    console.log(`Fetching contact count for pipeline ${pipelineId}, stage ${stageId}`);
    try {
      const response = await fetch(`/api/pipelines/search?pipelineId=${pipelineId}&stageId=${stageId}`);
      if (!response.ok) {
        throw new Error(`Failed to fetch stage ${stageId} for pipeline ${pipelineId}: ${response.status} ${response.statusText}`);
      }
      const data = await response.json();
      
      if (data.error) {
        throw new Error(`API error: ${data.message || 'Unknown error'}`);
      }
      
      console.log(`Stage ${stageId} count:`, data.total || 0);
      return data.total || 0;
    } catch (error) {
      console.error(`Error fetching stage ${stageId} contacts:`, error);
      return 0; // Return 0 on error
    }
  };

  // Add debugging to handleApplyFilters
  const handleApplyFilters = async () => {
    console.log('Apply filters clicked. Pipeline:', selectedPipeline, 'Stage:', selectedStage);
    
    if (!selectedPipeline) {
      toast.error('Please select a pipeline first');
      return;
    }
    
    // If stage is "all", show a confirmation since it might load a lot of contacts
    if (selectedStage === 'all') {
      if (!confirm('You are about to load all contacts in this pipeline. This may take some time. Continue?')) {
        return;
      }
    }
    
    console.log('Setting filtersApplied to true');
    setFiltersApplied(true);
    
    // If selecting a specific stage, immediately update the count
    if (selectedStage && selectedStage !== 'all') {
      try {
        console.log('Fetching stage contact count for stage:', selectedStage);
        const count = await fetchStageContacts(selectedPipeline, selectedStage);
        console.log('Stage contact count:', count);
        setStageContactCount(count);
      } catch (error) {
        console.error('Error fetching stage count:', error);
      }
    }
  };

  // Update the fetchPipelines function to properly store stage counts
  useEffect(() => {
    const fetchPipelines = async () => {
      try {
        const response = await fetch('/api/pipelines');
        if (!response.ok) {
          throw new Error('Failed to fetch pipelines');
        }
        const data = await response.json();
        const pipelinesArray = Array.isArray(data) ? data : Array.isArray(data.pipelines) ? data.pipelines : [];
        setPipelines(pipelinesArray);

        // Create a map to store stage counts
        const stageCountsMap: Record<string, number> = {};
        
        // For each pipeline, fetch counts for all stages
        for (const pipeline of pipelinesArray) {
          for (const stage of (pipeline.stages || [])) {
            try {
              const count = await fetchStageContacts(pipeline.id, stage.id);
              stageCountsMap[stage.id] = count;
            } catch (error) {
              console.error(`Error fetching count for stage ${stage.id}:`, error);
              stageCountsMap[stage.id] = 0;
            }
          }
        }
        
        // Update stage counts state
        setTotalLeadsByStage(stageCountsMap);
        
        // Calculate pipeline totals
        const pipelineTotals: Record<string, number> = {};
        for (const pipeline of pipelinesArray) {
          const pipelineTotal = (pipeline.stages || []).reduce((total: number, stage: any) => {
            return total + (stageCountsMap[stage.id] || 0);
          }, 0);
          pipelineTotals[pipeline.id] = pipelineTotal;
        }
        
        // Update pipeline totals state
        setTotalLeadsByPipeline(pipelineTotals);

        // If a pipeline is selected, initialize its stages
        if (selectedPipeline) {
          const selectedPipelineData = pipelinesArray.find((p: any) => p.id === selectedPipeline);
          if (selectedPipelineData) {
            setPipelineStages(selectedPipelineData.stages || []);
          }
        }
      } catch (error) {
        console.error('Error fetching pipelines:', error);
        toast.error('Failed to load pipelines');
        setPipelines([]);
      }
    };
    fetchPipelines();
  }, []);

  // Add this function to get the stage name
  const getSelectedStageName = () => {
    if (!selectedStage || selectedStage === 'all') return null;
    
    const stage = pipelineStages.find((s: any) => s.id === selectedStage);
    return stage?.name || null;
  };

  // Update the fetchContactsByStage function to add validation
  const fetchContactsByStage = async (pipelineId: string, stageId: string | null) => {
    if (!pipelineId) {
      console.error('No pipeline ID provided');
      return [];
    }
    
    setIsFetching(true);
    console.log('-------- NEW FETCH SESSION --------');
    console.log('Fetching contacts for pipeline:', pipelineId, 'stage:', stageId || 'all stages');
    
    // Show additional debug info about the selected stage
    if (stageId && stageId !== 'all' && totalLeadsByStage[stageId]) {
      const stageName = getSelectedStageName() || stageId;
      console.log(`Selected stage: ${stageName} (ID: ${stageId})`);
      console.log(`Expected contacts in this stage: ${totalLeadsByStage[stageId]}`);
    }
    
    // If we have an expected count for this stage, set it immediately to show the user
    if (stageId && stageId !== 'all' && totalLeadsByStage[stageId]) {
      setStageContactCount(totalLeadsByStage[stageId]);
    }
    
    try {
      // This will hold all contacts as we fetch them page by page
      let allContacts: any[] = [];
      
      // Find pipeline info for logging
      const selectedPipelineData = pipelines.find((p: any) => p.id === pipelineId);
      const pipelineName = selectedPipelineData?.name || 'Unknown Pipeline';
      console.log(`Selected pipeline: ${pipelineName} (ID: ${pipelineId})`);
      
      // The API seems to have a hard limit of 500 contacts per page
      // We'll explicitly fetch multiple pages to get all contacts
      const expectedCount = (stageId && stageId !== 'all' && totalLeadsByStage[stageId]) || 2000;
      const pageSize = 500; // API seems to cap at 500 regardless of what we request
      const pagesToFetch = Math.ceil(expectedCount / pageSize);
      
      console.log(`Need to fetch ${pagesToFetch} pages to get all ${expectedCount} contacts`);
      setLoadingProgress({ current: 0, total: pagesToFetch });
      
      // Fetch pages sequentially to avoid overloading the API and to show progress
      let loadedContacts: any[] = [];
      
      // Track all response data for debugging
      const allResponses: any[] = [];
      
      for (let page = 1; page <= pagesToFetch; page++) {
        const queryParams: Record<string, string> = {
          type: 'pipeline',
          pipelineId: pipelineId,
          limit: pageSize.toString(),
          page: page.toString(),
        };
        
        // Only add stageId if we're filtering by a specific stage
        if (stageId && stageId !== 'all') {
          queryParams.stageId = stageId;
          console.log(`Including stageId ${stageId} in API request`);
        } else {
          console.log(`Not filtering by stage in API request (all stages)`);
        }
        
        if (searchQuery) {
          queryParams.search = searchQuery;
        }
        
        const url = `/api/contacts/search?${new URLSearchParams(queryParams).toString()}`;
        console.log(`Fetching page ${page} of ${pagesToFetch} from URL:`, url);
        
        try {
          console.log(`Starting request to ${url}...`);
          const startTime = new Date().getTime();
          const response = await axios.get(url);
          const endTime = new Date().getTime();
          console.log(`Request completed in ${endTime - startTime}ms`);
          
          // Check if response has the expected structure
          if (!response.data) {
            console.error('API returned empty response');
            throw new Error('Empty response from API');
          }
          
          // Log the response structure for debugging
          console.log('Response data structure:', Object.keys(response.data));
          
          allResponses.push(response.data);
          
          // Access contacts array from the response data
          const pageContacts = response.data.contacts || [];
          console.log(`Received ${pageContacts.length} contacts from page ${page}`);
          
          // Check for API errors
          if (response.data.error) {
            console.error('API returned an error:', response.data.error);
            toast.error(`API error: ${response.data.error}`);
            continue;
          }
          
          // Check if contacts have stage info
          if (pageContacts.length > 0 && stageId && stageId !== 'all') {
            // Log all contacts for debugging
            console.log('All contacts from this page:', pageContacts);
            
            // Sample a few contacts to check their stage
            const sampleSize = Math.min(5, pageContacts.length);
            const sampleContacts = pageContacts.slice(0, sampleSize);
            console.log('Sample contacts to verify stage:', sampleContacts.map((c: any) => ({
              id: c.id,
              name: c.firstName || c.contactName,
              stageId: c.stageId || 'No stageId',
              // Include any other relevant fields
            })));
          }
          
          // Process the contacts to add a name field
          const processedContacts = pageContacts.map((contact: any) => ({
            ...contact,
            name: contact.contactName || contact.firstName || (contact.phone ? `Contact ${contact.phone.slice(-4)}` : 'Unknown Contact'),
          }));
          
          // Add to our collection
          loadedContacts = [...loadedContacts, ...processedContacts];
          
          // Update the contacts state to show progress
          setContacts(loadedContacts);
          
          // Update progress
          setLoadingProgress({ current: page, total: pagesToFetch });
          
          // If we got fewer contacts than expected, we might have reached the end
          if (pageContacts.length < pageSize) {
            console.log(`Received fewer contacts than expected on page ${page}, might be at the end`);
            // We'll still continue fetching other pages in case the API is inconsistent
            if (page < pagesToFetch) {
              // We can break early if we're clearly at the end
              if (pageContacts.length === 0) {
                console.log('Stopping early because we received 0 contacts');
                break;
              }
            }
          }
        } catch (error) {
          console.error(`Error fetching page ${page}:`, error);
        }
      }
      
      // Set the final result
      allContacts = loadedContacts;
      
      console.log(`Fetched ${allContacts.length} total contacts for ${stageId ? 'stage' : 'pipeline'}`);
      
      // Log summary of API responses to debug inconsistencies
      console.log('API response summary:', allResponses.map(r => ({
        total: r.total || 'unknown',
        contacts: (r.contacts || []).length
      })));
      
      // Also check the expected count if we're filtering by stage
      if (stageId && stageId !== 'all' && totalLeadsByStage[stageId]) {
        const expectedCount = totalLeadsByStage[stageId];
        console.log(`Expected count for stage ${stageId}: ${expectedCount}`);
        
        // If we have significantly fewer contacts than expected, log a warning
        if (allContacts.length < expectedCount * 0.9) {
          console.warn(`Warning: Fetched only ${allContacts.length} contacts out of expected ${expectedCount}`);
          toast.error(`Warning: Could only load ${allContacts.length} contacts out of expected ${expectedCount}. Some contacts may be missing.`);
        }
        
        // If we have significantly more contacts than expected, that's suspicious
        if (allContacts.length > expectedCount * 1.1) {
          console.warn(`Warning: Fetched ${allContacts.length} contacts but only expected ${expectedCount}`);
          toast.error(`Warning: Loaded ${allContacts.length} contacts, which is more than the expected ${expectedCount}. The API may not be filtering correctly.`);
        }
      }
      
      return allContacts;
    } catch (error) {
      console.error('Error fetching contacts by stage:', error);
      return [];
    } finally {
      setIsFetching(false);
      setLoadingProgress(null);
    }
  };

  // Update the useEffect that loads contacts to remove redundant client-side filtering
  useEffect(() => {
    // Only load contacts when filters have been explicitly applied
    if (!filtersApplied) {
      return;
    }
    
    const loadContacts = async () => {
      // Reset the state
      setContacts([]);
      setSelectedContacts([]);
      setCurrentPage(1);
      setTotalContacts(0);
      
      if (!selectedPipeline) {
        return;
      }
      
      try {
        // Display a loading toast
        const loadingToast = toast.loading(
          selectedStage && selectedStage !== 'all' 
            ? `Loading contacts for stage ${getSelectedStageName()}...` 
            : 'Loading all pipeline contacts...'
        );
        
        // Fetch the appropriate contacts based on pipeline/stage selection
        const fetchedContacts = await fetchContactsByStage(selectedPipeline, selectedStage);
        
        // Dismiss the loading toast
        toast.dismiss(loadingToast);
        
        // Instead of client-side filtering, trust that the API now filters correctly
        // Set the contacts directly from what the API returns
        setContacts(fetchedContacts);
        setTotalContacts(fetchedContacts.length);
        
        // If we didn't already set the stage count in fetchContactsByStage
        if (selectedStage && selectedStage !== 'all' && !stageContactCount) {
          setStageContactCount(fetchedContacts.length);
        } else if (selectedStage === 'all' || !selectedStage) {
          setStageContactCount(null);
        }
        
        if (fetchedContacts.length > 0) {
          // Pre-select all contacts by default
          setSelectedContacts(fetchedContacts);
          toast.success(`Loaded ${fetchedContacts.length} contacts successfully`);
        } else {
          toast.error('No contacts found for the selected criteria');
        }
      } catch (error) {
        console.error('Error loading contacts:', error);
        toast.error('Failed to load contacts');
      }
    };
    
    loadContacts();
  }, [selectedPipeline, selectedStage, filtersApplied]);

  // Add this function to analyze and display stage distribution of contacts
  // This can help diagnose if the API is not filtering properly
  const analyzeContactStages = (contacts: any[]) => {
    if (!contacts || contacts.length === 0) return null;
    
    // Count contacts by stage
    const stageDistribution: Record<string, number> = {};
    let contactsWithNoStage = 0;
    
    contacts.forEach(contact => {
      if (contact.stageId) {
        stageDistribution[contact.stageId] = (stageDistribution[contact.stageId] || 0) + 1;
      } else {
        contactsWithNoStage++;
      }
    });
    
    // Get stage names for display
    const stageInfos = Object.entries(stageDistribution).map(([stageId, count]) => {
      let stageName = 'Unknown Stage';
      
      // Try to find the stage name by looking through all pipelines
      for (const pipeline of pipelines) {
        const stage = pipeline.stages?.find((s: any) => s.id === stageId);
        if (stage) {
          stageName = stage.name;
          break;
        }
      }
      
      return { 
        stageId, 
        stageName, 
        count,
        percentage: Math.round((count / contacts.length) * 100)
      };
    }).sort((a, b) => b.count - a.count); // Sort by count descending
    
    return {
      totalAnalyzed: contacts.length,
      contactsWithNoStage,
      stageInfos
    };
  };

  return (
    <DashboardLayout title="Ringless Voicemails">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-10">
        <div className="md:flex md:items-center md:justify-between mb-8">
          <div className="flex-1 min-w-0">
            <h2 className="text-2xl font-bold leading-7 text-gray-900 sm:text-3xl sm:truncate">
              Ringless Voicemails
            </h2>
            <p className="mt-1 text-sm text-gray-500">
              Create new voicemail campaigns to reach your contacts.
            </p>
          </div>
          <div className="mt-4 flex md:mt-0 md:ml-4 space-x-3">
            <Link
              href="/ringless-voicemails/manual"
              className="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500"
            >
              Manual Voicemail
            </Link>
          </div>
        </div>

        {/* Stats Cards */}
        <div className="grid grid-cols-1 gap-5 sm:grid-cols-2 lg:grid-cols-4 mb-8">
          <StatsCard
            title="Total Contacts"
            value={stats.totalContacts}
            icon={
              <svg className="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
              </svg>
            }
            iconBgColor="bg-purple-100"
            iconColor="text-purple-600"
          />
          <StatsCard
            title="Delivered"
            value={stats.delivered}
            icon={<PhoneIcon className="w-6 h-6" />}
            iconBgColor="bg-green-100"
            iconColor="text-green-600"
          />
          <StatsCard
            title="Pending"
            value={stats.pending}
            icon={<PhoneIncomingIcon className="w-6 h-6" />}
            iconBgColor="bg-yellow-100"
            iconColor="text-yellow-600"
          />
          <StatsCard
            title="Failed"
            value={stats.failed}
            icon={<PhoneOffIcon className="w-6 h-6" />}
            iconBgColor="bg-red-100"
            iconColor="text-red-600"
          />
        </div>

        {/* Pipeline Selector */}
        <div className="bg-white shadow-sm border border-gray-200 rounded-lg mb-8">
          <div className="px-4 py-4">
            <div className="flex items-center justify-between">
              <div className="flex-1 min-w-0 flex flex-col sm:flex-row sm:items-center sm:space-x-4">
                <div className="w-full sm:w-1/2">
                  <PipelineSelector
                    pipelines={pipelines}
                    selectedPipeline={selectedPipeline}
                    handlePipelineChange={handlePipelineChange}
                  />
                  {selectedPipeline && <span className="ml-3 text-purple-600 font-medium">
                    {totalLeadsByPipeline[selectedPipeline] || 0} leads
                  </span>}
                </div>
                <div className="w-full sm:w-1/2 mt-3 sm:mt-0 flex items-center">
                  <div className="flex-grow">
                    <StageSelector
                      stages={pipelineStages}
                      selectedStage={selectedStage}
                      handleStageChange={handleStageChange}
                      disabled={!selectedPipeline}
                    />
                    {selectedStage !== 'all' && <span className="ml-3 text-purple-600 font-medium">
                      {selectedStage ? totalLeadsByStage[selectedStage] || 0 : 0} leads
                    </span>}
                  </div>
                  <button
                    onClick={handleApplyFilters}
                    disabled={!selectedPipeline}
                    className={`ml-3 px-4 py-2 text-sm font-medium rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 
                      ${!selectedPipeline 
                        ? 'bg-gray-300 text-gray-500 cursor-not-allowed' 
                        : 'bg-purple-600 text-white hover:bg-purple-700'}`}
                  >
                    Apply
                  </button>
                </div>
              </div>
              <div className="flex items-center space-x-3">
                <ViewToggle viewMode={viewMode} setViewMode={setViewMode} />
              </div>
            </div>
            {!filtersApplied && (
              <div className="mt-2 text-amber-600 text-sm">
                Please select a pipeline and stage, then click "Apply" to load contacts.
              </div>
            )}
          </div>
        </div>

        {/* Create New Campaign */}
        <div className="bg-white shadow overflow-hidden sm:rounded-lg mb-8">
          <div className="px-4 py-5 sm:p-6">
            <div className="flex justify-between items-center mb-6">
              <h3 className="text-lg leading-6 font-medium text-gray-900">Create New Campaign</h3>
              <button
                onClick={() => setIsBulkUploadModalOpen(true)}
                className="inline-flex items-center px-3 py-2 border border-purple-300 text-sm leading-4 font-medium rounded-md text-purple-700 bg-white hover:bg-purple-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500"
              >
                Bulk Upload Contacts
              </button>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-12 gap-6">
              {/* Contact Selection - 5 columns */}
              <div className="lg:col-span-5 flex flex-col h-full">
                <div className="flex-grow overflow-hidden border border-gray-200 rounded-lg">
                  {loadingProgress && (
                    <div className="bg-purple-100 text-purple-800 p-2 text-sm text-center">
                      Loading contacts: {loadingProgress.current} of {loadingProgress.total} pages 
                      ({Math.round((loadingProgress.current / loadingProgress.total) * 100)}%)
                    </div>
                  )}
                  
                  {selectedStage && selectedStage !== 'all' && contacts.length > 0 && (() => {
                    const analysis = analyzeContactStages(contacts);
                    if (!analysis) return null;
                    
                    // Check if we have contacts from other stages
                    const otherStagesCount = analysis.stageInfos
                      .filter(info => info.stageId !== selectedStage)
                      .reduce((sum, info) => sum + info.count, 0);
                    
                    if (otherStagesCount > 0) {
                      // We have contacts from other stages - there's a filtering issue
                      return (
                        <div className="bg-red-100 text-red-800 p-2 text-sm">
                          <p className="font-semibold">Warning: API filter issue detected</p>
                          <p>Of {analysis.totalAnalyzed} contacts loaded:</p>
                          <ul className="list-disc list-inside">
                            {analysis.stageInfos.map(info => (
                              <li key={info.stageId}>
                                {info.stageName}: {info.count} contacts ({info.percentage}%)
                                {info.stageId === selectedStage && " âœ“"}
                              </li>
                            ))}
                          </ul>
                        </div>
                      );
                    }
                    
                    return null;
                  })()}
                  
                  <ContactSelector
                    contacts={contacts}
                    selectedContacts={selectedContacts}
                    searchQuery={searchQuery}
                    isSearching={isSearching}
                    isFetching={isFetching}
                    totalContacts={stageContactCount !== null ? stageContactCount : totalContacts}
                    onSearchChange={handleSearchChange}
                    onToggleContact={toggleContact}
                    onClearSelected={() => setSelectedContacts([])}
                    onOpenBulkUpload={() => setIsBulkUploadModalOpen(true)}
                    loaderRef={loaderRef}
                    stageName={getSelectedStageName()}
                  />
                </div>
              </div>

              {/* Campaign Settings - 7 columns */}
              <div className="lg:col-span-7"> 

                <CampaignForm
                  isVoiceMailModule={true}
                  campaignName={campaignName}
                  script={script}
                  phoneNumbers={phoneNumbers}
                  selectedPhoneNumber={selectedPhoneNumber}
                  voiceClones={voiceClones}
                  selectedVoiceClone={selectedVoiceClone}
                  settings={settings}
                  selectedContacts={selectedContacts}
                  onNameChange={setCampaignName}
                  onScriptChange={setScript}
                  onPhoneNumberChange={(value) => setSelectedPhoneNumber(phoneNumbers.find((p) => p === value) || null)}
                  onVoiceCloneChange={setSelectedVoiceClone}
                  onSettingsSave={handleUpdateSettings}
                  onGenerateScript={generateDefaultScript}
                  onCreateCampaign={async () => {
                    if (confirm(`Create "${campaignName}" with ${selectedContacts.length} contacts?`)) {
                      await createCampaign();
                    }
                  }}
                  onRefreshVoiceClones={() => {
                    fetchVoiceClones();
                    toast.success("Loading voice clones...");
                  }}
                />
              </div>
            </div>
          </div>
        </div>

        {isBulkUploadModalOpen && (
          <div
            className="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50"
            onClick={() => setIsBulkUploadModalOpen(false)}
          >
            <div
              className="bg-white rounded-xl shadow-xl w-full max-w-4xl p-6"
              onClick={(e) => e.stopPropagation()}
            >
              <EnhancedBulkUploadForm onContactsSelect={handleBulkUpload} isLoading={isSubmitting} />
            </div>
          </div>
        )}

        <CampaignList
          isVoiceMailModule={true}
          campaigns={campaigns}
          loading={loading}
          error={error}
          onPause={(id) => handleCampaignAction(id, 'pause')}
          onResume={(id) => handleCampaignAction(id, 'resume')}
          onDelete={handleDeleteCampaign}
        />
      </div>
    </DashboardLayout>
  );
}